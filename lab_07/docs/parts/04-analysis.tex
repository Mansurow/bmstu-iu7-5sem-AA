\chapter{Аналитическая часть}
В данном разделе будут рассмотрены словарь как структура данных и алгоритм полного перебора, а также представлены требования к разрабатываемой программе.

\section{Словарь как структура данных}

Словарь \cite{dict} --- абстрактный тип данных (интерфейс к хранилищу данных), позволяющий хранить пары вида «(ключ, значение)» и поддерживающий операции добавления пары, а также поиска и удаления пары по ключу:
\begin{enumerate}[label=\arabic*)]
	\item \textit{insert(k, v)};
	\item \textit{find(k)};
	\item \textit{remove(k)}.
\end{enumerate}

В паре \textit{(k, v)}: \textit{v} называется значением, ассоциированным с ключом \textit{k}. Где \textit{k} --- это ключ, a \textit{v} — значение. Семантика и названия вышеупомянутых операций в разных реализациях ассоциативного массива могут отличаться.

Операция поиска \textit{find(k)} возвращает значение, ассоциированное с заданным ключом, или некоторый специальный объект, означающий, что значения, ассоциированного с заданным ключом, нет. Две другие операции ничего не возвращают (за исключением, возможно, информации о том, успешно ли была выполнена данная операция).

Словарь с точки зрения интерфейса удобно рассматривать как обычный массив, в котором в качестве индексов можно использовать не только целые числа, но и значения других типов --- например, строки (именно по этой причине словарь также иногда называют <<ассоциативным массивом>>).

\section{Алгоритм полного перебора}
Алгоритмом полного перебора \cite{AI} называют метод решения задачи, при котором по очереди рассматриваются все возможные варианты. В случае реализации алгоритма в рамках данной работы будут последовательно перебираться ключи словаря до тех пор, пока не будет найден нужный.

Трудоёмкость алгоритма зависит от того, присутствует ли искомый ключ в словаре, и, если присутствует -- насколько он далеко от начала массива ключей.
Пусть на старте алгоритм затрагивает $k_{0}$ операций, а при сравнении $k_{1}$ операций.

Пусть алгоритм нашёл элемент на первом сравнении (лучший случай), тогда будет затрачено $k_0 + k_1$ операций, на втором --- $k_0 + 2 \cdot k_1$, на последнем (худший случай) --- $k_0 + N \cdot k_1$. Если ключа нет в массиве ключей, то мы сможем понять это, только перебрав все ключи, таким образом трудоёмкость такого случая равно трудоёмкости случая с ключом на последней позиции. Трудоёмкость в среднем может быть рассчитана как математическое ожидание по формуле (\ref{for:brute}), где $\Omega$ --- множество всех возможных случаев.

\begin{equation}
	\label{for:brute}
	\begin{aligned}
		\sum\limits_{i \in \Omega} p_i \cdot f_i = k_0 + k_1 \cdot \left(1 + \frac{N}{2} - \frac{1}{N + 1}\right)
	\end{aligned}
\end{equation}

\section{Требования к программе}

К разрабатываемой в данной работе программе предъявляется ряд требований:
\begin{enumerate}[label=\arabic*)]
	\item на вход будет подаваться строка, на основании которой производится поиск;
	\item на выходе --- результат поиска в словаре;
	\item программа не должна аварийно завершаться при отсутствии ключа в словаре.
\end{enumerate}

\section*{Вывод}

В данном разделе были рассмотрены словарь как структура данных и алгоритм полного перебора, а также приведены требования к разрабатываемой программе.