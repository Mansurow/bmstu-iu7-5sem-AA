\chapter{Исследовательская часть}

\section{Технические характеристики}

Технические характеристики устройства, на котором выполнялись замеры по времени представлены далее.

\begin{itemize}
	\item Процессор: Intel(R) Core(TM) i5-10300H CPU @ 2.50 ГГц 2.50 ГГц. \cite{intel}
	\item Оперативная память: 16 ГБ.
	\item Операционная система: Windows 10 Pro 64-разрядная система версией 21H2. \cite{windows}
\end{itemize}

При замерах времени ноутбук был включен в сеть электропитания и был нагружен только системными приложениями.

\clearpage

\section{Демонстрация работы программы}

\begin{figure}[h]
	\centering
	\includegraphics[height=0.7\textheight]{img/example.png}
	\caption{Демонстрация работы программы при поиске расстояний Левенштейна и Дамерау-Левенштейна}
	\label{img:demonstration}
\end{figure}

\clearpage

\section{Временные характеристики}

Результаты эксперимента замеров по времени приведены в Таблице \ref{tbl:time}, в которой есть поля обозначены "\--" это обусловлено тем для рекурсивной реализации алгоритмов при больших длин строк, алгоритм работает довольно долго, то есть для таких длин строк замеры не выполнялись.

\begin{table}[ht]
	\small
	\caption{Замер по времени для строк, размер которых от 1 до 200}
	\label{tbl:time}
	\begin{center}
		\begin{tabular}{|c|c|c|c|c|}
			\hline
			& \multicolumn{4}{c|}{\bfseries Время, нс} \\ \cline{2-5}
			& \multicolumn{1}{c|}{\bfseries Левенштейн}
			& \multicolumn{3}{c|}{\bfseries Дамерау-Левенштейн} \\ \cline{2-5}
			\bfseries Длина (символ) & \bfseries Итеративный & \bfseries Итеративный & \multicolumn{2}{c|}{\bfseries Рекурсивный} \\ \cline{4-5}
			& & & \bfseries Без кэша & \bfseries С кэшом
			\csvreader{csv/time.csv}{}
			{\\\hline \csvcoli & \csvcolii & \csvcoliii & \csvcoliv & \csvcolv} \\
			\hline
		\end{tabular}
	\end{center}
\end{table}

Отдельно сравним итеративные алгоритмы поиска расстояний Левенштейна и Дамерау--Левенштейна. Сравнение будет производится на основе данных, представленных в Таблице \ref{tbl:time}. Результат можно рассмотреть на Рисунке \ref{plt:time_01}.

При длинах строк менее 30 символов разница по времени между
итеративными реализациями незначительна, однако при увеличении длины
строки алгоритм поиска расстояния Левенштейна оказывается быстрее
вплоть до полутора раз (при длинах строк равных 200). Это обосновывается
тем, что у алгоритма поиска расстояния Дамерау-Левенштейна задействуется
дополнительная операция, которая замедляет алгоритм.

\begin{figure}[h]
	\centering
	\includegraphics[height=0.3\textheight]{img/diag_01.png}
	\caption{Сравнение по времени нерекурсивных реализаций алгоритмов поиска расстояний Левенштейна и Дамерау-Левенштейна}
	\label{plt:time_01}
\end{figure}

Так же сравним рекурсивную и итеративную реализации алгоритма поиска расстояния Дамерау-Левенштейна. Данные представлены в Таблице \ref{tbl:time} и отображены на Рисунке \ref{plt:time_02}.

\begin{figure}[h]
	\centering
	\includegraphics[height=0.3\textheight]{img/diag_02.png}
	\caption{Сравнение по времени алгоритмов поиска расстояния Дамерау-Левенштейна}
	\label{plt:time_02}
\end{figure}

На Рисунке \ref{plt:time_02} продемонстрировано, что рекурсивный алгоритм становится менее эффективным (вплоть до 21 раз при длине строк равной 7 элементов), чем итеративный.

Из этого можно сделать вывод о том, что рекурсивный алгоритм неэффективно использовать по времени.

Кроме того, согласно данным, приведенным в Таблице \ref{tbl:time}, рекурсивные алгоритмы при длинах строк более 10 элементов не пригодны к использованию в силу экспоненциально роста затрат процессорного времени, в то время, как затраты итеративных алгоритмов по времени линейны.

\section{Характеристики по памяти}

Введем следующие обозначения:
\begin{itemize}
	\item$n$ - длина строки $S_{1}$;
	\item$m$ - длина строки $S_{2}$;
	\item$size()$ - функция вычисляющая размер в байтах;
	\item $string$ - строковый тип;
	\item $int$ - целочисленный тип;
	\item $size\_t$ - беззнаковый целочисленный тип.
\end{itemize}

Максимальная глубина стека вызовов при рекурсивной реализации нахождения расстояния Дамерау-Левенштейна равна сумме входящих строк, а на каждый вызов требуется 4 дополнительных переменных, соответственно, максимальный расход памяти \ref{eq:dl_rec_memory}:
\begin{equation}
	\label{eq:dl_rec_memory}
	(n + m) \cdot (2 \cdot size(string) + 3 \cdot size(int) + 2 \cdot sizeof(size\_t)),
\end{equation}
где:
\begin{itemize}
	\item $2 \cdot size(string)$ -- хранение двух строк;
	\item $2 \cdot size(size\_t)$ -- хранение размеров строк;
	\item $2 \cdot size(int)$ -- дополнительные переменные;
	\item $size(int)$ -- адрес возврата.
\end{itemize}

Для рекурсивного алгоритма c кэшированием Дамерау-Левенштейна будет теоретически тоже самое, что и в рекурсивном, но добавляется еще размер матрицы, соответственно, максимальный расход памяти \ref{eq:dl_hash_memory}:
\begin{equation}
	\label{eq:dl_hash_memory}
	\begin{aligned}
		(n + m) \cdot (2 \cdot size(string) + 3 \cdot size(int) + 2 \cdot size(size\_t)) + \\
		+ (n + 1) \cdot (m + 1) \cdot size(int)
	\end{aligned}
\end{equation}
Использование памяти при итеративной реализации расстояния Левенштейна теоретически равно \ref{eq:lev_mtr_memory}:

\begin{equation}
	\label{eq:lev_mtr_memory}
	\begin{aligned}
		(n + 1) \cdot (m + 1) \cdot size(int) + 2 \cdot size(string) + 2 \cdot size(size\_t) + \\
		+ size(int **) + (n + 1) \cdot size(int *) + 2 \cdot size(int),
	\end{aligned}
\end{equation}
где 
\begin{itemize}
	\item $2 \cdot size(string)$ -- хранение двух строк;
	\item $2 \cdot size(size\_t)$ -- хранение размеров матрицы;
	\item $(n + 1) \cdot (m + 1) \cdot size(int)$ -- хранение матрицы;
	\item $size(int **) + (n + 1) \cdot size(int *)$ -- указатель на матрицу;
	\item $size(int)$ -- дополнительная переменная для хранения результата;
	\item $size(int)$ -- адрес возврата.
\end{itemize}

Использование памяти при итеративной реализации расстояния Дамерау-Левенштейна теоретически равно \ref{eq:dl_mtr_memory}:
\begin{equation}
	\label{eq:dl_mtr_memory}
	\begin{aligned}
		(n + 1) \cdot (m + 1) \cdot size(int) + 2 \cdot size(string) + 2 \cdot size(size\_t) + \\
		+ size(int **) + (n + 1) \cdot size(int *) + 3 \cdot size(int),
	\end{aligned}
\end{equation}
где 
\begin{itemize}
	\item $2 * size(string)$ -- хранение двух строк;
	\item $2 \cdot size(size\_t)$ -- хранение размеров матрицы;
	\item $(n + 1) \cdot (m + 1) \cdot size(int)$ -- хранение матрицы;
	\item $size(int **) + (n + 1) \cdot size(int *)$ -- указатель на матрицу;
	\item $2 \cdot size(int)$ -- дополнительные переменные;
	\item $size(int)$ -- адрес возврата.
\end{itemize}

По расходу памяти итеративные алгоритмы проигрывают рекурсивным: максимальный размер используемой памяти в них растет как произведение длин строк, в то время как у рекурсивного алгоритма — как сумма длин строк.

По формулам \ref{eq:dl_rec_memory} - \ref{eq:lev_mtr_memory} затрат по памяти в программе были написаны соответствующие функции для подсчета расходуемой памяти, результаты расчетов которых представлены в таблице \ref{tbl:memory}, где размеры строк от 10 до 200.

\begin{table}[ht]
	\small
	\caption{Замер памяти для строк, размером от 10 до 200}
	\label{tbl:memory}
	\begin{center}
		\begin{tabular}{|c|c|c|c|c|}
			\hline
			& \multicolumn{4}{c|}{\bfseries Размер в байтах} \\ \cline{2-5}
			& \multicolumn{1}{c|}{\bfseries Левенштейн}
			& \multicolumn{3}{c|}{\bfseries Дамерау-Левенштейн} \\ \cline{2-5}
			\bfseries Длина (символ) & \bfseries Итеративный & \bfseries Итеративный & \multicolumn{2}{c|}{\bfseries Рекурсивный} \\ \cline{4-5}
			& & & \bfseries Без кэша & \bfseries С кэшом
			\csvreader{csv/memory.csv}{}
			{\\\hline \csvcoli & \csvcolii & \csvcoliii & \csvcoliv & \csvcolv} \\
			\hline
		\end{tabular}
	\end{center}
\end{table}

\clearpage

Из данных, приведенных в Таблице \ref{tbl:memory}, видно, что рекурсивные алгоритмы являются более эффективными по памяти, так как используется только память под локальные переменные, передаваемые аргументы и возвращаемое значение, в то время как итеративные алгоритмы затрачивают память линейно пропорционально длинам обрабатываемых строк.

\begin{figure}[h]
	\centering
	\includegraphics[height=0.3\textheight]{img/diag_03.png}
	\caption{Сравнение по памяти алгоритмов поиска расстояния Левенштейна и Дамерау-Левенштейна --- итеративной и рекурсивной реализации}
	\label{plt:memory}
\end{figure}

\clearpage

Как видно из Рисунка \ref{plt:memory_1}, можно увидеть что рекурсивная реализация алгоритма поиска расстояния Дамерау-Левенштейна эффективная по памяти, чем итеративная.

\begin{figure}[h]
	\centering
	\includegraphics[height=0.3\textheight]{img/diag_04.png}
	\caption{Сравнение по памяти алгоритмов поиска расстояния Дамерау-Левенштейна --- итеративной и рекурсивной реализации}
	\label{plt:memory_1}
\end{figure}

\clearpage

\section{Вывод}
В данном разделе было произведено сравнение количества затраченного времени и памяти вышеизложенных алгоритмов. Наименее затратным по времени оказался итеративный алгоритм нахождения расстояния Левенштейна.

Приведенные характеристики показывают нам, что рекурсивная реализация алгоритма очень сильно проигрывает по времени. В связи с этим, рекурсивные алгоритмы следует использовать лишь для малых размерностей строк (1-4 символа).

Так как во время печати очень часто возникают ошибки связанные с транспозицией букв, алгоритм поиска расстояния Дамерау-Левенштейна является наиболее предпочтительным, не смотря на то, что он проигрывает по времени и памяти алгоритму Левенштейна.

Можно сделать вывод о том, что рекуррентный алгоритм поиска расстояния Дамерау-Левенштейна будет более затратным по времени по сравнению с итеративной реализацией алгоритма поиска расстояния Дамерау-Левенштейна, но менее затратным по памяти по отношению к итеративному алгоритму.
